import os
import difflib
import logging
from typing import Dict, Any, Optional
from pathlib import Path
import tempfile
import shutil

logger = logging.getLogger(__name__)

from analytics_engine import analytics_engine

class DiffStagingLayer:
    """
    Safely intercepts file writes generated by AI agents.
    Provides a staging mechanism to generate unified diffs
    and requires explicit approval before applying atomic patches.
    """
    def __init__(self, workspace_dir: str):
        self.workspace_dir = Path(workspace_dir).resolve() if workspace_dir else None
        # In-memory dictionary of pending patches: { "/absolute/path": "new_content" }
        self.staged_patches: Dict[str, str] = {}

    def _is_safe_path(self, filepath: Path) -> bool:
        if not self.workspace_dir:
            return False
        return str(filepath.resolve()).startswith(str(self.workspace_dir))

    def propose_patch(self, relative_or_absolute_path: str, new_content: str) -> Dict[str, Any]:
        """
        Intercepts a write request, generates a unified diff, and stages the patch in memory.
        Returns a structured dictionary representing the diff preview.
        """
        if not self.workspace_dir:
            return {"error": "Workspace not loaded. Cannot propose patch."}

        # Normalize the path
        path_obj = Path(relative_or_absolute_path)
        if not path_obj.is_absolute():
            path_obj = self.workspace_dir / path_obj
            
        path_obj = path_obj.resolve()
        
        if not self._is_safe_path(path_obj):
            logger.error(f"[SECURITY] Denied out-of-bounds patch proposal to {path_obj}")
            return {"error": "Security Block: Cannot propose patches outside workspace directory."}

        abs_path_str = str(path_obj)
        
        # Read original content if file exists
        original_content = ""
        if path_obj.exists() and path_obj.is_file():
            try:
                original_content = path_obj.read_text(encoding='utf-8')
            except UnicodeDecodeError:
                return {"error": "Cannot propose patches for binary files."}

        # Generate Unified Diff
        diff_lines = list(difflib.unified_diff(
            original_content.splitlines(keepends=True),
            new_content.splitlines(keepends=True),
            fromfile=f"a/{path_obj.name}",
            tofile=f"b/{path_obj.name}",
            n=3
        ))
        unified_diff = "".join(diff_lines)

        if not unified_diff.strip():
            return {"status": "unchanged", "message": "The proposed content exactly matches the existing file."}

        # Stage it into memory
        self.staged_patches[abs_path_str] = new_content
        
        logger.info(f"[STAGING] Generated patch for {path_obj.name} ({len(unified_diff)} bytes of diff)")

        return {
            "status": "staged",
            "file": abs_path_str,
            "filename": path_obj.name,
            "diff": unified_diff,
            "action": "modify" if path_obj.exists() else "create"
        }

    def apply_patch(self, absolute_path: str) -> Dict[str, Any]:
        """
        Atomically applies a staged patch to the filesystem.
        Uses a temporary file and atomic rename to prevent corruption.
        """
        if absolute_path not in self.staged_patches:
            return {"error": f"No staged patch found for {absolute_path}"}

        path_obj = Path(absolute_path)
        new_content = self.staged_patches[absolute_path]
        
        try:
            # Atomic Write Strategy
            path_obj.parent.mkdir(parents=True, exist_ok=True)
            
            # Write to a secure temporary file first
            fd, temp_path = tempfile.mkstemp(dir=str(path_obj.parent), prefix=".diff_tmp_")
            with os.fdopen(fd, 'w', encoding='utf-8') as f:
                f.write(new_content)
                f.flush()
                os.fsync(f.fileno()) # Force write to disk

            # Atomically replace the target file (works natively on POSIX and Windows >= Python 3.3)
            os.replace(temp_path, absolute_path)
            
            # Clear from staging memory on success
            del self.staged_patches[absolute_path]
            
            logger.info(f"[APPLIED] Patch applied atomically to {path_obj.name}")
            
            # Analytics Hook
            analytics_engine.log_event("patch_applied", {"file": absolute_path, "filename": path_obj.name})
            
            return {"status": "success", "file": absolute_path}
            
        except Exception as e:
            # [RECOVERY] Clean up temp file if something blew up
            if 'temp_path' in locals() and os.path.exists(temp_path):
                try:
                    os.remove(temp_path)
                except Exception:
                    pass
            logger.error(f"[ROLLBACK] Failed to apply patch atomically: {e}. File pristine.")
            return {"error": f"Atomic write failed: {str(e)}"}

    def discard_patch(self, absolute_path: str) -> Dict[str, str]:
        """Discards a staged patch from memory without writing to disk."""
        if absolute_path in self.staged_patches:
            del self.staged_patches[absolute_path]
            
            # Analytics Hook
            analytics_engine.log_event("patch_rejected", {"file": absolute_path})
            
            return {"status": "discarded", "message": "Patch rejected successfully."}
        return {"error": "Patch not found in staging buffer."}

    def clear_all(self):
        """Clears all staged patches."""
        self.staged_patches.clear()
        logger.info("[STAGING] Cleared all pending patches.")
